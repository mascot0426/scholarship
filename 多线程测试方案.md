# 多线程实现测试方案

## 测试目标

测试两个多线程类：
1. **ConflictChecker** - 冲突检查线程
2. **ExportThread** - 报表导出线程

验证多线程功能是否正常工作，确保UI不被阻塞。

---

## 一、ConflictChecker 测试

### 1.1 测试环境准备

#### 准备测试数据
```sql
-- 创建测试学生
INSERT INTO users (username, password, role, name) 
VALUES ('test_student', 'hash_password', 2, '测试学生');

-- 创建测试活动1（已批准）
INSERT INTO activities (title, description, category, organizer, start_time, end_time, max_participants, status)
VALUES ('活动A', '测试活动A', '学术', '发起人1', '2024-01-15 10:00:00', '2024-01-15 12:00:00', 50, 1);

-- 创建测试活动2（已批准，与活动A时间冲突）
INSERT INTO activities (title, description, category, organizer, start_time, end_time, max_participants, status)
VALUES ('活动B', '测试活动B', '体育', '发起人2', '2024-01-15 11:00:00', '2024-01-15 13:00:00', 50, 1);

-- 学生报名活动A
INSERT INTO registrations (activity_id, student_id, student_name, status)
VALUES (1, 'test_student', '测试学生', 0);
```

### 1.2 单元测试代码

创建测试文件 `test_conflictchecker.cpp`：

```cpp
#include <QtTest/QtTest>
#include "conflictchecker.h"
#include "database.h"

class ConflictCheckerTest : public QObject
{
    Q_OBJECT

private slots:
    void initTestCase();      // 测试前初始化
    void cleanupTestCase();   // 测试后清理
    void testNoConflict();    // 测试无冲突情况
    void testHasConflict();   // 测试有冲突情况
    void testEmptyStudentId(); // 测试空学号
    void testInvalidActivityId(); // 测试无效活动ID
    void testThreadNonBlocking(); // 测试线程不阻塞

private:
    Database *database;
    ConflictChecker *checker;
};

void ConflictCheckerTest::initTestCase()
{
    database = new Database(this);
    QVERIFY(database->initializeDatabase());
    
    // 准备测试数据（见1.1节）
    // ... 插入测试数据 ...
}

void ConflictCheckerTest::testNoConflict()
{
    checker = new ConflictChecker(database, this);
    
    QSignalSpy spy(checker, &ConflictChecker::checkCompleted);
    
    QDateTime startTime = QDateTime::fromString("2024-01-16 10:00:00", "yyyy-MM-dd hh:mm:ss");
    QDateTime endTime = QDateTime::fromString("2024-01-16 12:00:00", "yyyy-MM-dd hh:mm:ss");
    
    checker->setStudentId("test_student");
    checker->setActivityTime(2, startTime, endTime);
    
    checker->start();
    QVERIFY(spy.wait(5000)); // 等待最多5秒
    
    QList<QVariant> arguments = spy.takeFirst();
    QCOMPARE(arguments.at(0).toBool(), false); // 应该无冲突
}

void ConflictCheckerTest::testHasConflict()
{
    checker = new ConflictChecker(database, this);
    
    QSignalSpy completedSpy(checker, &ConflictChecker::checkCompleted);
    QSignalSpy conflictSpy(checker, &ConflictChecker::conflictDetected);
    
    QDateTime startTime = QDateTime::fromString("2024-01-15 11:00:00", "yyyy-MM-dd hh:mm:ss");
    QDateTime endTime = QDateTime::fromString("2024-01-15 13:00:00", "yyyy-MM-dd hh:mm:ss");
    
    checker->setStudentId("test_student");
    checker->setActivityTime(2, startTime, endTime);
    
    checker->start();
    QVERIFY(completedSpy.wait(5000));
    QVERIFY(conflictSpy.wait(5000));
    
    QList<QVariant> arguments = completedSpy.takeFirst();
    QCOMPARE(arguments.at(0).toBool(), true); // 应该有冲突
    
    QList<QVariant> conflictArgs = conflictSpy.takeFirst();
    QList<QHash<QString, QVariant>> conflicts = 
        qvariant_cast<QList<QHash<QString, QVariant>>>(conflictArgs.at(0));
    QVERIFY(!conflicts.isEmpty());
}

void ConflictCheckerTest::testThreadNonBlocking()
{
    checker = new ConflictChecker(database, this);
    
    QTime startTime = QTime::currentTime();
    
    QDateTime activityStart = QDateTime::fromString("2024-01-15 11:00:00", "yyyy-MM-dd hh:mm:ss");
    QDateTime activityEnd = QDateTime::fromString("2024-01-15 13:00:00", "yyyy-MM-dd hh:mm:ss");
    
    checker->setStudentId("test_student");
    checker->setActivityTime(2, activityStart, activityEnd);
    
    checker->start();
    
    // 在等待期间，UI应该可以响应
    QTime checkTime = QTime::currentTime();
    int elapsed = startTime.msecsTo(checkTime);
    QVERIFY(elapsed < 100); // 启动线程应该几乎立即返回
    
    QSignalSpy spy(checker, &ConflictChecker::checkCompleted);
    spy.wait(5000);
    
    QVERIFY(checker->isFinished());
}

void ConflictCheckerTest::cleanupTestCase()
{
    // 清理测试数据
    delete database;
}
```

### 1.3 功能测试步骤

#### 测试步骤1：基本冲突检测
1. 启动应用程序
2. 以学生身份登录（test_student）
3. 进入"报名管理"标签页
4. 尝试报名一个与已报名活动时间冲突的活动
5. **验证**：应该弹出冲突提示对话框
6. **验证**：UI界面应该保持响应，不卡顿

#### 测试步骤2：无冲突情况
1. 尝试报名一个与已报名活动时间不冲突的活动
2. **验证**：应该直接允许报名，不显示冲突提示

#### 测试步骤3：UI响应性测试
1. 在冲突检查进行时，尝试：
   - 点击其他按钮
   - 切换标签页
   - 滚动列表
2. **验证**：所有UI操作应该立即响应，无延迟

### 1.4 性能测试

```cpp
void ConflictCheckerTest::testPerformance()
{
    // 测试大量活动时的性能
    QTime timer;
    timer.start();
    
    checker = new ConflictChecker(database, this);
    checker->setStudentId("test_student");
    checker->setActivityTime(100, startTime, endTime);
    
    checker->start();
    
    QSignalSpy spy(checker, &ConflictChecker::checkCompleted);
    spy.wait(10000); // 等待10秒
    
    int elapsed = timer.elapsed();
    qDebug() << "冲突检查耗时：" << elapsed << "ms";
    
    // 对于100个活动，应该在1秒内完成
    QVERIFY(elapsed < 1000);
}
```

---

## 二、ExportThread 测试

### 2.1 测试环境准备

准备大量测试数据用于导出测试：
- 至少100个活动
- 每个活动至少50个报名记录
- 总计至少5000条数据

### 2.2 单元测试代码

创建测试文件 `test_exportthread.cpp`：

```cpp
#include <QtTest/QtTest>
#include "exportthread.h"
#include "database.h"
#include <QFile>
#include <QDir>

class ExportThreadTest : public QObject
{
    Q_OBJECT

private slots:
    void initTestCase();
    void cleanupTestCase();
    void testExportRegistrations();
    void testExportStatistics();
    void testExportProgress();
    void testThreadNonBlocking();
    void testLargeDataExport();
    void testExportError();

private:
    Database *database;
    ExportThread *exportThread;
    QString testDir;
};

void ExportThreadTest::initTestCase()
{
    database = new Database(this);
    QVERIFY(database->initializeDatabase());
    
    testDir = QDir::tempPath() + "/export_test";
    QDir().mkpath(testDir);
}

void ExportThreadTest::testExportRegistrations()
{
    exportThread = new ExportThread(this);
    
    QSignalSpy finishedSpy(exportThread, &ExportThread::exportFinished);
    
    // 准备测试数据
    QList<QHash<QString, QVariant>> registrations;
    QHash<QString, QVariant> reg;
    reg["student_id"] = "S001";
    reg["student_name"] = "学生1";
    reg["registered_at"] = QDateTime::currentDateTime();
    registrations.append(reg);
    
    QHash<QString, QVariant> activity;
    activity["title"] = "测试活动";
    activity["category"] = "学术";
    activity["organizer"] = "发起人";
    
    QString filename = testDir + "/test_registrations.csv";
    
    exportThread->setExportType("registrations");
    exportThread->setFilename(filename);
    exportThread->setRegistrationsData(registrations, activity);
    
    exportThread->start();
    QVERIFY(finishedSpy.wait(10000)); // 等待10秒
    
    QList<QVariant> arguments = finishedSpy.takeFirst();
    QCOMPARE(arguments.at(0).toBool(), true); // 应该成功
    
    // 验证文件存在
    QVERIFY(QFile::exists(filename));
    
    // 验证文件内容
    QFile file(filename);
    QVERIFY(file.open(QIODevice::ReadOnly));
    QString content = file.readAll();
    QVERIFY(content.contains("测试活动"));
    QVERIFY(content.contains("S001"));
}

void ExportThreadTest::testExportStatistics()
{
    exportThread = new ExportThread(this);
    
    QSignalSpy finishedSpy(exportThread, &ExportThread::exportFinished);
    
    // 准备统计数据
    QList<QHash<QString, QVariant>> statistics;
    for (int i = 0; i < 10; ++i) {
        QHash<QString, QVariant> stat;
        stat["id"] = i + 1;
        stat["title"] = QString("活动%1").arg(i + 1);
        stat["current_participants"] = 10 + i;
        statistics.append(stat);
    }
    
    QString filename = testDir + "/test_statistics.csv";
    
    exportThread->setExportType("statistics");
    exportThread->setFilename(filename);
    exportThread->setStatisticsData(statistics);
    
    exportThread->start();
    QVERIFY(finishedSpy.wait(10000));
    
    QList<QVariant> arguments = finishedSpy.takeFirst();
    QCOMPARE(arguments.at(0).toBool(), true);
    
    QVERIFY(QFile::exists(filename));
}

void ExportThreadTest::testExportProgress()
{
    exportThread = new ExportThread(this);
    
    QSignalSpy progressSpy(exportThread, &ExportThread::exportProgress);
    
    // 准备大量数据以触发进度更新
    QList<QHash<QString, QVariant>> statistics;
    for (int i = 0; i < 100; ++i) {
        QHash<QString, QVariant> stat;
        stat["id"] = i + 1;
        stat["title"] = QString("活动%1").arg(i + 1);
        statistics.append(stat);
    }
    
    QString filename = testDir + "/test_progress.csv";
    
    exportThread->setExportType("statistics");
    exportThread->setFilename(filename);
    exportThread->setStatisticsData(statistics);
    
    exportThread->start();
    
    // 等待进度信号
    QVERIFY(progressSpy.wait(10000));
    
    // 验证收到了进度信号
    QVERIFY(progressSpy.count() > 0);
    
    // 验证进度值在合理范围内
    QList<QVariant> arguments = progressSpy.takeFirst();
    int progress = arguments.at(0).toInt();
    QVERIFY(progress >= 0 && progress <= 100);
}

void ExportThreadTest::testThreadNonBlocking()
{
    exportThread = new ExportThread(this);
    
    QTime startTime = QTime::currentTime();
    
    // 准备大量数据
    QList<QHash<QString, QVariant>> statistics;
    for (int i = 0; i < 1000; ++i) {
        QHash<QString, QVariant> stat;
        stat["id"] = i + 1;
        stat["title"] = QString("活动%1").arg(i + 1);
        statistics.append(stat);
    }
    
    QString filename = testDir + "/test_nonblocking.csv";
    
    exportThread->setExportType("statistics");
    exportThread->setFilename(filename);
    exportThread->setStatisticsData(statistics);
    
    exportThread->start();
    
    // 启动线程应该立即返回
    QTime checkTime = QTime::currentTime();
    int elapsed = startTime.msecsTo(checkTime);
    QVERIFY(elapsed < 100);
    
    QSignalSpy spy(exportThread, &ExportThread::exportFinished);
    spy.wait(30000); // 等待导出完成
    
    QVERIFY(exportThread->isFinished());
}

void ExportThreadTest::testLargeDataExport()
{
    exportThread = new ExportThread(this);
    
    QTime timer;
    timer.start();
    
    // 准备大量数据（模拟真实场景）
    QList<QHash<QString, QVariant>> statistics;
    for (int i = 0; i < 500; ++i) {
        QHash<QString, QVariant> stat;
        stat["id"] = i + 1;
        stat["title"] = QString("活动%1").arg(i + 1);
        stat["category"] = "测试类别";
        stat["organizer"] = "发起人";
        stat["current_participants"] = 50;
        stat["max_participants"] = 100;
        statistics.append(stat);
    }
    
    QString filename = testDir + "/test_large.csv";
    
    exportThread->setExportType("statistics");
    exportThread->setFilename(filename);
    exportThread->setStatisticsData(statistics);
    
    exportThread->start();
    
    QSignalSpy spy(exportThread, &ExportThread::exportFinished);
    spy.wait(60000); // 等待60秒
    
    int elapsed = timer.elapsed();
    qDebug() << "导出500条记录耗时：" << elapsed << "ms";
    
    QList<QVariant> arguments = spy.takeFirst();
    QCOMPARE(arguments.at(0).toBool(), true);
    
    // 验证文件大小
    QFileInfo fileInfo(filename);
    QVERIFY(fileInfo.size() > 0);
}

void ExportThreadTest::testExportError()
{
    exportThread = new ExportThread(this);
    
    QSignalSpy errorSpy(exportThread, &ExportThread::exportError);
    
    // 使用无效的导出类型
    exportThread->setExportType("invalid_type");
    exportThread->setFilename(testDir + "/test_error.csv");
    
    exportThread->start();
    
    QVERIFY(errorSpy.wait(5000));
    
    QList<QVariant> arguments = errorSpy.takeFirst();
    QString error = arguments.at(0).toString();
    QVERIFY(error.contains("未知的导出类型"));
}

void ExportThreadTest::cleanupTestCase()
{
    // 清理测试文件
    QDir(testDir).removeRecursively();
    delete database;
}
```

### 2.3 功能测试步骤

#### 测试步骤1：导出报名名单
1. 启动应用程序
2. 以管理员身份登录
3. 进入"报名管理"标签页
4. 选择一个活动
5. 点击"导出报名名单"按钮
6. **验证**：
   - 应该弹出文件保存对话框
   - 选择保存位置后，导出应该在后台进行
   - UI应该保持响应
   - 导出完成后应该显示成功提示
   - 文件应该正确生成

#### 测试步骤2：导出统计报表
1. 以管理员身份登录
2. 点击菜单"文件" -> "导出统计报表"
3. **验证**：
   - 应该显示导出进度（如果有进度条）
   - UI应该保持响应，可以继续操作其他功能
   - 导出完成后应该显示成功提示
   - CSV文件应该正确生成

#### 测试步骤3：UI响应性测试
1. 开始导出大量数据（500+条记录）
2. 在导出过程中：
   - 点击其他菜单项
   - 切换标签页
   - 查看活动列表
   - 尝试其他操作
3. **验证**：所有UI操作应该立即响应，无卡顿

#### 测试步骤4：进度显示测试
1. 导出大量数据（100+条记录）
2. **验证**：应该能看到进度更新（如果UI有进度条）
3. **验证**：进度值应该从0%逐渐增加到100%

### 2.4 性能对比测试

测试多线程导出 vs 单线程导出的性能差异：

```cpp
void ExportThreadTest::testPerformanceComparison()
{
    // 准备大量数据
    QList<QHash<QString, QVariant>> statistics;
    for (int i = 0; i < 1000; ++i) {
        // ... 添加数据 ...
    }
    
    // 测试多线程导出
    QTime timer1;
    timer1.start();
    exportThread = new ExportThread(this);
    exportThread->setExportType("statistics");
    exportThread->setFilename(testDir + "/multithread.csv");
    exportThread->setStatisticsData(statistics);
    exportThread->start();
    
    QSignalSpy spy1(exportThread, &ExportThread::exportFinished);
    spy1.wait(60000);
    int multithreadTime = timer1.elapsed();
    
    // 测试单线程导出（直接调用CsvExporter）
    QTime timer2;
    timer2.start();
    CsvExporter exporter;
    exporter.exportStatistics(testDir + "/singlethread.csv", statistics);
    int singlethreadTime = timer2.elapsed();
    
    qDebug() << "多线程导出耗时：" << multithreadTime << "ms";
    qDebug() << "单线程导出耗时：" << singlethreadTime << "ms";
    
    // 多线程应该不会比单线程慢太多（因为主要是I/O操作）
    // 但多线程的优势在于不阻塞UI
}
```

---

## 三、集成测试

### 3.1 完整流程测试

#### 测试场景：报名时异步冲突检查
1. 学生登录系统
2. 已报名活动A（10:00-12:00）
3. 尝试报名活动B（11:00-13:00，时间冲突）
4. **验证**：
   - 冲突检查应该在后台线程进行
   - UI应该保持响应
   - 检查完成后应该显示冲突提示
   - 学生可以选择是否继续报名

#### 测试场景：导出大量数据
1. 管理员登录系统
2. 系统中有500+个活动，每个活动有50+个报名
3. 导出统计报表
4. **验证**：
   - 导出过程不应该阻塞UI
   - 可以同时进行其他操作
   - 导出完成后文件应该正确生成
   - 文件内容应该完整准确

### 3.2 并发测试

```cpp
void testConcurrentOperations()
{
    // 测试同时进行多个导出操作
    ExportThread *thread1 = new ExportThread(this);
    ExportThread *thread2 = new ExportThread(this);
    ExportThread *thread3 = new ExportThread(this);
    
    // 同时启动三个导出任务
    thread1->setExportType("statistics");
    thread1->setFilename("export1.csv");
    thread1->start();
    
    thread2->setExportType("statistics");
    thread2->setFilename("export2.csv");
    thread2->start();
    
    thread3->setExportType("statistics");
    thread3->setFilename("export3.csv");
    thread3->start();
    
    // 等待所有线程完成
    thread1->wait();
    thread2->wait();
    thread3->wait();
    
    // 验证所有文件都正确生成
    QVERIFY(QFile::exists("export1.csv"));
    QVERIFY(QFile::exists("export2.csv"));
    QVERIFY(QFile::exists("export3.csv"));
}
```

---

## 四、边界情况测试

### 4.1 ConflictChecker 边界测试

1. **空学号测试**
   - 设置空学号
   - 应该返回无冲突（或错误）

2. **无效活动ID测试**
   - 设置活动ID为-1或0
   - 应该返回无冲突

3. **无已报名活动测试**
   - 学生没有任何已报名活动
   - 应该返回无冲突

4. **大量冲突活动测试**
   - 学生已报名100个活动
   - 检查新活动是否与所有活动冲突
   - 应该能正确检测所有冲突

### 4.2 ExportThread 边界测试

1. **空数据导出测试**
   - 导出空列表
   - 应该生成空的CSV文件（只有表头）

2. **无效文件路径测试**
   - 使用无效路径（如只读目录）
   - 应该触发错误信号

3. **超大文件导出测试**
   - 导出10000+条记录
   - 应该能正常完成，不崩溃

4. **特殊字符测试**
   - 数据中包含逗号、引号、换行符
   - CSV文件应该正确转义

---

## 五、测试工具和脚本

### 5.1 创建测试项目文件

在 `.pro` 文件中添加测试配置：

```pro
# 测试配置
CONFIG += testcase
QT += testlib

# 测试源文件
SOURCES += \
    test_conflictchecker.cpp \
    test_exportthread.cpp

HEADERS += \
    test_conflictchecker.h \
    test_exportthread.h
```

### 5.2 运行测试

```bash
# 编译测试
qmake
make

# 运行所有测试
./exp_PesernoalWork_test

# 运行特定测试
./exp_PesernoalWork_test ConflictCheckerTest
./exp_PesernoalWork_test ExportThreadTest
```

### 5.3 手动测试检查清单

#### ConflictChecker 检查清单
- [ ] 无冲突情况正常工作
- [ ] 有冲突情况正确检测
- [ ] 冲突信息完整准确
- [ ] UI在检查过程中保持响应
- [ ] 信号正确发送
- [ ] 线程正确结束

#### ExportThread 检查清单
- [ ] 报名名单导出成功
- [ ] 统计报表导出成功
- [ ] 进度信号正确发送
- [ ] 完成信号正确发送
- [ ] 错误信号正确处理
- [ ] UI在导出过程中保持响应
- [ ] 文件格式正确
- [ ] 文件内容完整

---

## 六、常见问题和解决方案

### Q1: 测试时线程没有完成怎么办？
**A**: 增加等待时间，或检查信号连接是否正确。

### Q2: 如何验证UI确实没有被阻塞？
**A**: 在测试中添加UI操作（如点击按钮），验证操作能立即响应。

### Q3: 如何测试线程安全性？
**A**: 使用并发测试，同时启动多个线程，验证数据一致性。

### Q4: 导出文件格式不正确怎么办？
**A**: 检查CSV转义逻辑，验证特殊字符处理。

---

## 七、测试报告模板

### 测试结果记录

| 测试项 | 预期结果 | 实际结果 | 状态 | 备注 |
|--------|----------|----------|------|------|
| ConflictChecker无冲突 | 返回false | ✓ | 通过 | |
| ConflictChecker有冲突 | 返回true并发送冲突列表 | ✓ | 通过 | |
| ExportThread导出报名 | 文件生成成功 | ✓ | 通过 | |
| ExportThread导出统计 | 文件生成成功 | ✓ | 通过 | |
| UI响应性 | UI不阻塞 | ✓ | 通过 | |
| 进度显示 | 进度正确更新 | ✓ | 通过 | |

### 性能测试结果

- ConflictChecker平均响应时间：< 100ms
- ExportThread导出1000条记录：< 5秒
- UI响应延迟：< 50ms

---

## 八、总结

通过以上测试方案，可以全面验证多线程实现的正确性和性能。重点验证：
1. **功能正确性**：多线程类能正确完成其功能
2. **UI响应性**：UI在后台操作时保持响应
3. **信号机制**：信号和槽正确工作
4. **边界情况**：各种边界情况都能正确处理
5. **性能**：多线程实现不会带来明显的性能损失

