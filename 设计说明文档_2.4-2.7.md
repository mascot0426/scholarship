# 校园活动管理系统设计说明文档

## 2.4 Model/View 设计说明

### 2.4.1 E-R 图（实体关系图）

```
┌─────────────────────────────────────────────────────────────────┐
│                        实体关系图 (E-R Diagram)                  │
└─────────────────────────────────────────────────────────────────┘

┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│    users     │         │  activities  │         │registrations │
├──────────────┤         ├──────────────┤         ├──────────────┤
│ student_id   │◄───────│ id           │◄───────│ id           │
│ (PK)         │         │ (PK)         │         │ (PK)         │
│ password     │         │ title        │         │ activity_id  │
│ role         │         │ description  │         │ (FK)         │
│ name         │         │ category     │         │ student_id   │
│ created_at   │         │ organizer    │         │ (FK)         │
└──────────────┘         │ start_time   │         │ student_name │
                         │ end_time     │         │ status       │
                         │ max_particip. │         │ registered_at│
                         │ current_part. │         │ checkin_time │
                         │ location      │         └──────────────┘
                         │ status        │                 │
                         │ created_at    │                 │
                         │ approved_at   │                 │
                         │ approved_by   │                 │
                         │ checkin_code  │                 │
                         └──────────────┘                 │
                                                           │
                         ┌──────────────┐                 │
                         │   waitlist   │                 │
                         ├──────────────┤                 │
                         │ id           │                 │
                         │ (PK)         │                 │
                         │ activity_id  │                 │
                         │ (FK)         │                 │
                         │ student_id   │                 │
                         │ (FK)         │                 │
                         │ student_name │                 │
                         │ added_at     │                 │
                         └──────────────┘                 │
                                                           │
                                                           │
                    ┌──────────────────────────────────────┘
                    │
                    │ 关系说明：
                    │ 1. users (1) ──(创建)── (N) activities
                    │    - 一个用户可以创建多个活动
                    │    - organizer字段关联users.student_id
                    │
                    │ 2. activities (1) ──(报名)── (N) registrations
                    │    - 一个活动可以有多个报名记录
                    │    - activity_id外键关联activities.id
                    │
                    │ 3. users (1) ──(报名)── (N) registrations
                    │    - 一个用户可以报名多个活动
                    │    - student_id外键关联users.student_id
                    │
                    │ 4. activities (1) ──(候补)── (N) waitlist
                    │    - 一个活动可以有多个候补记录
                    │    - activity_id外键关联activities.id
                    │
                    │ 5. users (1) ──(候补)── (N) waitlist
                    │    - 一个用户可以在多个活动的候补列表中
                    │    - student_id外键关联users.student_id
                    │
                    │ 约束：
                    │ - registrations表：UNIQUE(activity_id, student_id)
                    │   确保一个学生只能报名一次同一活动
                    │ - waitlist表：UNIQUE(activity_id, student_id)
                    │   确保一个学生在同一活动的候补列表中只出现一次
                    │ - 外键约束：ON DELETE CASCADE
                    │   删除活动时自动删除相关报名和候补记录
```

### 2.4.2 数据表结构说明

#### 表1：users（用户表）

| 字段名 | 数据类型 | 约束 | 说明 |
|--------|---------|------|------|
| student_id | TEXT | PRIMARY KEY, NOT NULL | 学号，作为主键，唯一标识用户 |
| password | TEXT | NOT NULL | 密码（SHA256哈希值） |
| role | INTEGER | NOT NULL | 用户角色：0=管理员，1=发起人，2=学生 |
| name | TEXT | NULL | 用户姓名 |
| created_at | DATETIME | DEFAULT CURRENT_TIMESTAMP | 账户创建时间 |

**字段规范说明**：
- `student_id`：学号格式，如"2021001"，作为主键，不能为空
- `password`：存储SHA256哈希后的密码，不存储明文
- `role`：枚举值，使用UserRole枚举类定义
- `name`：用户真实姓名，可为空
- `created_at`：自动记录账户创建时间

**索引**：
- 主键索引：student_id（自动创建）

#### 表2：activities（活动表）

| 字段名 | 数据类型 | 约束 | 说明 |
|--------|---------|------|------|
| id | INTEGER | PRIMARY KEY, AUTOINCREMENT | 活动ID，自增主键 |
| title | TEXT | NOT NULL | 活动标题 |
| description | TEXT | NULL | 活动描述 |
| category | TEXT | NULL | 活动类别（如：学术讲座、文体活动等） |
| organizer | TEXT | NOT NULL | 发起人学号（外键关联users.student_id） |
| start_time | DATETIME | NOT NULL | 活动开始时间 |
| end_time | DATETIME | NOT NULL | 活动结束时间 |
| max_participants | INTEGER | NOT NULL | 最大参与人数 |
| current_participants | INTEGER | DEFAULT 0 | 当前参与人数 |
| location | TEXT | NULL | 活动地点 |
| status | INTEGER | DEFAULT 0 | 活动状态：0=待审批，1=已批准，2=已拒绝，3=进行中，4=已结束 |
| created_at | DATETIME | DEFAULT CURRENT_TIMESTAMP | 活动创建时间 |
| approved_at | DATETIME | NULL | 审批时间 |
| approved_by | TEXT | NULL | 审批人学号 |
| checkin_code | TEXT | NULL | 签到码（用于学生签到验证） |

**字段规范说明**：
- `id`：自增整数，唯一标识活动
- `title`：活动标题，必填，长度建议不超过100字符
- `description`：活动详细描述，可为空
- `category`：活动类别，建议使用预定义类别列表
- `organizer`：发起人学号，必须存在于users表中
- `start_time`、`end_time`：使用ISO格式日期时间，end_time必须晚于start_time
- `max_participants`：正整数，表示活动最大容纳人数
- `current_participants`：当前已报名人数，由系统自动维护
- `status`：使用ActivityStatus枚举类定义
- `checkin_code`：6位数字或字母组合，用于学生端签到验证

**索引**：
- 主键索引：id（自动创建）
- 普通索引：status（idx_activities_status），用于快速查询特定状态的活动

#### 表3：registrations（报名表）

| 字段名 | 数据类型 | 约束 | 说明 |
|--------|---------|------|------|
| id | INTEGER | PRIMARY KEY, AUTOINCREMENT | 报名记录ID |
| activity_id | INTEGER | NOT NULL, FOREIGN KEY | 活动ID（外键关联activities.id） |
| student_id | TEXT | NOT NULL, FOREIGN KEY | 学生学号（外键关联users.student_id） |
| student_name | TEXT | NOT NULL | 学生姓名 |
| status | INTEGER | DEFAULT 0 | 报名状态：0=已报名，1=已取消，2=候补，3=已确认 |
| registered_at | DATETIME | DEFAULT CURRENT_TIMESTAMP | 报名时间 |
| checkin_time | DATETIME | NULL | 签到时间（NULL表示未签到） |

**字段规范说明**：
- `id`：自增整数，唯一标识报名记录
- `activity_id`：外键，关联activities表，级联删除
- `student_id`：外键，关联users表
- `student_name`：冗余字段，存储报名时的学生姓名，避免关联查询
- `status`：使用RegistrationStatus枚举类定义
- `registered_at`：记录报名时间，用于排序和统计
- `checkin_time`：签到时间，NULL表示未签到

**约束**：
- UNIQUE(activity_id, student_id)：确保一个学生只能报名一次同一活动
- FOREIGN KEY (activity_id) REFERENCES activities(id) ON DELETE CASCADE
- FOREIGN KEY (student_id) REFERENCES users(student_id)

**索引**：
- 普通索引：activity_id（idx_registrations_activity），用于快速查询某活动的报名列表
- 普通索引：student_id（idx_registrations_student），用于快速查询某学生的报名记录

#### 表4：waitlist（候补表）

| 字段名 | 数据类型 | 约束 | 说明 |
|--------|---------|------|------|
| id | INTEGER | PRIMARY KEY, AUTOINCREMENT | 候补记录ID |
| activity_id | INTEGER | NOT NULL, FOREIGN KEY | 活动ID（外键关联activities.id） |
| student_id | TEXT | NOT NULL, FOREIGN KEY | 学生学号（外键关联users.student_id） |
| student_name | TEXT | NOT NULL | 学生姓名 |
| added_at | DATETIME | DEFAULT CURRENT_TIMESTAMP | 加入候补列表时间 |

**字段规范说明**：
- `id`：自增整数，唯一标识候补记录
- `activity_id`：外键，关联activities表，级联删除
- `student_id`：外键，关联users表
- `student_name`：冗余字段，存储候补时的学生姓名
- `added_at`：记录加入候补列表的时间，用于FIFO排队

**约束**：
- UNIQUE(activity_id, student_id)：确保一个学生在同一活动的候补列表中只出现一次
- FOREIGN KEY (activity_id) REFERENCES activities(id) ON DELETE CASCADE
- FOREIGN KEY (student_id) REFERENCES users(student_id)

**索引**：
- 普通索引：activity_id（idx_waitlist_activity），用于快速查询某活动的候补列表

### 2.4.3 使用的Model类型说明

#### 当前实现方式

本系统当前使用 **QTableWidget** 作为数据展示控件，而不是标准的Model/View架构（QSqlTableModel + QTableView）。

**使用的Model类型**：
- **QTableWidget**：直接填充数据的表格控件
- **Database类**：封装了所有数据库操作，返回QHash/QList数据结构

**代码示例**：
```cpp
// ActivityManager中的实现
void ActivityManager::populateTable()
{
    QList<QHash<QString, QVariant>> activities = database->getActivities(filter);
    activitiesTable->setRowCount(activities.size());
    
    for (int i = 0; i < activities.size(); ++i) {
        const auto &activity = activities[i];
        activitiesTable->setItem(i, 0, new QTableWidgetItem(activity["id"].toString()));
        activitiesTable->setItem(i, 1, new QTableWidgetItem(activity["title"].toString()));
        // ... 填充其他列
    }
}
```

#### 为什么使用QTableWidget而不是Model/View？

1. **业务逻辑复杂**：
   - 需要根据用户角色动态过滤数据（发起人只能看到自己创建的活动，学生只能看到已批准的活动）
   - 需要多表关联查询（报名列表需要关联activities表获取活动信息）
   - QSqlTableModel难以直接支持复杂的关联查询和动态过滤

2. **自定义显示格式**：
   - 需要将枚举值（如状态）转换为中文显示
   - 需要格式化日期时间显示
   - 需要显示计算字段（如签到率）

3. **灵活的数据操作**：
   - 需要从多个数据源组合数据
   - 需要动态计算和显示统计信息

4. **数据层封装**：
   - Database模块提供了统一的数据访问接口，返回标准化的数据结构
   - 业务逻辑层（ActivityManager、RegistrationManager）负责数据转换和格式化
   - UI层只负责显示，实现了数据与视图的分离

### 2.4.4 为什么用Model/View而不是直接往控件塞数据？

虽然当前实现使用了QTableWidget直接填充数据，但系统设计考虑了数据与视图的分离：

1. **数据层封装**：
   - Database模块提供了统一的数据访问接口，返回标准化的数据结构（QHash/QList）
   - 所有数据库操作都通过Database类进行，不直接在UI层操作数据库

2. **业务逻辑分离**：
   - ActivityManager和RegistrationManager负责数据转换和格式化
   - UI层只负责显示，不包含业务逻辑

3. **可扩展性**：
   - 如果未来需要改用Model/View架构，只需修改populateTable()方法
   - 将数据填充到Model中，View自动更新

**当前架构的优势**：
- 代码简单直观，易于理解和维护
- 灵活性高，可以轻松实现复杂的显示逻辑
- 性能良好，对于中小规模数据量足够高效

### 2.4.5 使用ProxyModel如何过滤数据？

如果采用Model/View架构，可以使用QSortFilterProxyModel进行数据过滤：

```cpp
// 伪代码示例：使用QSqlTableModel + QSortFilterProxyModel

// 1. 创建基础Model
QSqlTableModel *model = new QSqlTableModel(this, database->getDatabase());
model->setTable("activities");
model->setFilter("status = 1");  // 只显示已批准的活动
model->select();

// 2. 创建ProxyModel进行进一步过滤
QSortFilterProxyModel *proxyModel = new QSortFilterProxyModel(this);
proxyModel->setSourceModel(model);

// 3. 按类别过滤
proxyModel->setFilterKeyColumn(2);  // 类别列索引
proxyModel->setFilterRegExp("学术讲座");  // 只显示"学术讲座"类别

// 4. 按发起人过滤（如果是发起人角色）
if (userRole == UserRole::Organizer) {
    proxyModel->setFilterKeyColumn(4);  // organizer列索引
    proxyModel->setFilterRegExp(currentStudentId);
}

// 5. 支持排序
proxyModel->setSortCaseSensitivity(Qt::CaseInsensitive);
proxyModel->sort(1, Qt::AscendingOrder);  // 按标题排序

// 6. 创建View并绑定
QTableView *view = new QTableView(this);
view->setModel(proxyModel);

// 7. 设置列宽和显示属性
view->setColumnWidth(0, 50);
view->setColumnWidth(1, 200);
view->horizontalHeader()->setStretchLastSection(true);
```

**ProxyModel的优势**：
- 支持多列过滤和排序
- 支持正则表达式过滤
- 不修改原始数据，只改变显示
- 可以链式使用多个ProxyModel

### 2.4.6 View（如QTableView）如何绑定Model？

如果使用QTableView绑定Model：

```cpp
// 方式1：直接绑定QSqlTableModel
QSqlTableModel *model = new QSqlTableModel(this, db);
model->setTable("activities");
model->setEditStrategy(QSqlTableModel::OnManualSubmit);
model->select();

QTableView *tableView = new QTableView(this);
tableView->setModel(model);

// 设置列宽
tableView->setColumnWidth(0, 50);
tableView->setColumnWidth(1, 200);
tableView->horizontalHeader()->setStretchLastSection(true);

// 隐藏某些列
tableView->hideColumn(0);  // 隐藏ID列

// 设置列标题
model->setHeaderData(0, Qt::Horizontal, "ID");
model->setHeaderData(1, Qt::Horizontal, "标题");

// 方式2：通过ProxyModel绑定
QSqlTableModel *sourceModel = new QSqlTableModel(this, db);
sourceModel->setTable("activities");
sourceModel->select();

QSortFilterProxyModel *proxyModel = new QSortFilterProxyModel(this);
proxyModel->setSourceModel(sourceModel);

QTableView *tableView = new QTableView(this);
tableView->setModel(proxyModel);  // 绑定ProxyModel而不是SourceModel
```

**绑定后的自动更新**：
- 当Model数据变化时，View自动更新显示
- 用户编辑View中的数据时，可以通过Model的submitAll()保存到数据库
- 支持撤销操作（OnManualSubmit策略）

### 2.4.7 Model/View架构示意图

```
┌─────────────────────────────────────────────────────────────────┐
│                    Model/View 架构示意图                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    UI层 (View Layer)                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              QTableView (View)                           │  │
│  │  ┌────────────────────────────────────────────────────┐  │  │
│  │  │  功能：                                            │  │  │
│  │  │  • 显示数据                                        │  │  │
│  │  │  • 处理用户交互（选择、编辑）                      │  │  │
│  │  │  • 发送编辑信号到Model                            │  │  │
│  │  │  • 自动响应Model数据变化                          │  │  │
│  │  └────────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────────┘  │
│                            ▲                                    │
│                            │ setModel()                         │
│                            │                                    │
└────────────────────────────┼────────────────────────────────────┘
                             │
┌────────────────────────────┼────────────────────────────────────┐
│                   代理层 (Proxy Layer)                          │
├────────────────────────────┼────────────────────────────────────┤
│                            │                                    │
│  ┌─────────────────────────▼──────────────────────────────────┐ │
│  │        QSortFilterProxyModel (Proxy)                      │ │
│  │  ┌────────────────────────────────────────────────────┐   │ │
│  │  │  功能：                                            │   │ │
│  │  │  • 过滤数据（按条件、正则表达式）                  │   │ │
│  │  │  • 排序数据（多列排序）                            │   │ │
│  │  │  • 转换数据格式                                    │   │ │
│  │  │  • 不修改原始数据，只改变显示                      │   │ │
│  │  └────────────────────────────────────────────────────┘   │ │
│  └──────────────────────────────────────────────────────────┘ │
│                            ▲                                    │
│                            │ setSourceModel()                   │
│                            │                                    │
└────────────────────────────┼────────────────────────────────────┘
                             │
┌────────────────────────────┼────────────────────────────────────┐
│                   模型层 (Model Layer)                           │
├────────────────────────────┼────────────────────────────────────┤
│                            │                                    │
│  ┌─────────────────────────▼──────────────────────────────────┐ │
│  │         QSqlTableModel (Model)                             │ │
│  │  ┌────────────────────────────────────────────────────┐   │ │
│  │  │  功能：                                            │   │ │
│  │  │  • 数据访问（SQL查询）                            │   │ │
│  │  │  • 数据缓存管理                                    │   │ │
│  │  │  • 数据编辑（增删改）                              │   │ │
│  │  │  • 数据验证                                        │   │ │
│  │  │  • 发送数据变化信号                                │   │ │
│  │  └────────────────────────────────────────────────────┘   │ │
│  └──────────────────────────────────────────────────────────┘ │
│                            ▲                                    │
│                            │ SQL查询                             │
│                            │                                    │
└────────────────────────────┼────────────────────────────────────┘
                             │
┌────────────────────────────┼────────────────────────────────────┐
│                   数据层 (Data Layer)                             │
├────────────────────────────┼────────────────────────────────────┤
│                            │                                    │
│  ┌─────────────────────────▼──────────────────────────────────┐ │
│  │              SQLite Database                              │ │
│  │  ┌────────────────────────────────────────────────────┐   │ │
│  │  │  • users表                                         │   │ │
│  │  │  • activities表                                    │   │ │
│  │  │  • registrations表                                │   │ │
│  │  │  • waitlist表                                     │   │ │
│  │  └────────────────────────────────────────────────────┘   │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

数据流向说明：
1. 用户操作View → View发送信号 → Model处理 → 更新数据库
2. 数据库变化 → Model查询 → Model发送信号 → View自动更新
3. ProxyModel在Model和View之间，对数据进行过滤和排序
```

**文字说明**：

本系统当前采用QTableWidget直接填充数据的方式，主要考虑到业务逻辑的复杂性和灵活性需求。系统通过Database模块实现了数据访问层的封装，ActivityManager和RegistrationManager负责数据的获取、过滤和格式化，然后填充到QTableWidget中显示。

如果未来需要改用Model/View架构，可以使用QSqlTableModel作为数据模型，QSortFilterProxyModel进行过滤和排序，QTableView作为视图。ProxyModel可以动态过滤数据，支持正则表达式过滤、多列过滤等功能，同时保持数据与视图的分离，便于维护和扩展。

---

## 2.5 网络模块设计

### 2.5.1 使用的网络协议

系统使用 **HTTP协议** 进行网络通信，通过 **QNetworkAccessManager** 实现异步HTTP请求。

**协议选择理由**：
- HTTP协议简单易用，适合RESTful API调用
- QNetworkAccessManager支持异步操作，不阻塞UI线程
- 支持GET和POST请求，满足不同场景需求
- 易于调试和测试

### 2.5.2 请求流程说明

```
┌─────────────────────────────────────────────────────────────────┐
│                    网络请求流程图                                │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┐
│  ActivityManager│
│  (UI层)         │
│                 │
│  用户点击"同步" │
└────────┬────────┘
         │ 1. 调用syncActivityToPlatform(activityId, activityData)
         ▼
┌─────────────────┐
│ NetworkManager  │
│                 │
│ 2. 构建JSON数据 │
│    - 将活动数据转换为QJsonObject
│    - 设置Content-Type: application/json
│                 │
│ 3. 创建QNetwork │
│    Request      │
│    - URL: baseUrl + "/activities/sync"
│    - Method: POST
│    - Headers: Content-Type
│                 │
│ 4. 发送POST请求 │
│    - networkManager->post(request, jsonData)
│    - 异步执行，立即返回
└────────┬────────┘
         │ 5. HTTP POST请求
         │    (不阻塞UI线程)
         ▼
┌─────────────────┐
│  校园平台API    │
│  (外部服务器)   │
│  http://local-  │
│  host:8090/api  │
│                 │
│  处理请求       │
│  返回JSON响应   │
└────────┬────────┘
         │ 6. HTTP响应
         │    Status: 200 OK
         │    Body: {"success": true, "message": "同步成功"}
         ▼
┌─────────────────┐
│ NetworkManager  │
│                 │
│ 7. 接收响应     │
│    - onSyncActivityReplyFinished()槽函数被调用
│    - 检查网络错误
│                 │
│ 8. 解析JSON     │
│    - QJsonDocument::fromJson()
│    - 提取success和message字段
│                 │
│ 9. 处理错误     │
│    - 网络错误：emit errorOccurred()
│    - JSON解析错误：emit errorOccurred()
│    - 成功：emit activitySynced(activityId, true)
└────────┬────────┘
         │ 10. emit activitySynced(activityId, success)
         │     emit errorOccurred(errorString)
         ▼
┌─────────────────┐
│  ActivityManager│
│  (UI层)         │
│                 │
│ 11. 接收信号    │
│     - 连接activitySynced信号
│     - 显示成功/失败消息框
│     - 更新UI状态
│                 │
│ 12. 刷新活动列表│
│     - 可选：调用refreshActivities()
└─────────────────┘
```

### 2.5.3 详细流程步骤

#### 步骤1：请求发起
```cpp
// ActivityManager中
void ActivityManager::onManualSync()
{
    int activityId = getSelectedActivityId();
    QHash<QString, QVariant> activity = database->getActivity(activityId);
    networkManager->syncActivityToPlatform(activityId, activity);
}
```

#### 步骤2：数据准备
```cpp
// NetworkManager中
void NetworkManager::syncActivityToPlatform(int activityId, const QHash<QString, QVariant> &activityData)
{
    // 构建JSON数据
    QJsonObject json;
    json["id"] = activityId;
    json["title"] = activityData["title"].toString();
    json["description"] = activityData["description"].toString();
    // ... 其他字段
    
    QJsonDocument doc(json);
    QByteArray data = doc.toJson();
}
```

#### 步骤3：创建请求
```cpp
QUrl url(baseUrl + "/activities/sync");
QNetworkRequest request(url);
request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
```

#### 步骤4：异步发送
```cpp
syncActivityReply = networkManager->post(request, data);
// 立即返回，不阻塞UI线程
```

#### 步骤5：响应处理
```cpp
void NetworkManager::onSyncActivityReplyFinished()
{
    if (syncActivityReply->error() == QNetworkReply::NoError) {
        QByteArray data = syncActivityReply->readAll();
        QJsonDocument doc = QJsonDocument::fromJson(data);
        // 解析并处理响应
        emit activitySynced(activityId, success);
    } else {
        emit errorOccurred(errorString);
    }
}
```

### 2.5.4 数据接收后如何更新UI

#### 方式1：信号槽连接（推荐）

```cpp
// ActivityManager构造函数中
connect(networkManager, &NetworkManager::activitySynced, 
        this, [this](int id, bool success) {
    if (success) {
        QMessageBox::information(this, "同步成功", 
            QString("活动 #%1 已成功同步到校园平台！").arg(id));
        statusLabel->setText("同步成功");
    } else {
        QMessageBox::warning(this, "同步失败", 
            QString("活动 #%1 同步失败，请检查网络连接！").arg(id));
        statusLabel->setText("同步失败");
    }
});

// 连接错误信号
connect(networkManager, &NetworkManager::errorOccurred,
        this, [this](const QString &error) {
    QMessageBox::warning(this, "网络错误", error);
    statusLabel->setText("网络错误：" + error);
});
```

#### 方式2：在主窗口中统一处理

```cpp
// MainWindow中
void MainWindow::setupNetworkConnections()
{
    connect(networkManager, &NetworkManager::categoriesReceived, 
            this, &MainWindow::onCategoriesReceived);
    connect(networkManager, &NetworkManager::announcementsReceived,
            this, &MainWindow::onAnnouncementsReceived);
    connect(networkManager, &NetworkManager::errorOccurred,
            this, &MainWindow::onNetworkError);
}
```

**UI更新特点**：
- 异步更新：网络请求在后台线程执行，不阻塞UI
- 信号驱动：通过Qt信号槽机制通知UI更新
- 线程安全：QNetworkAccessManager自动处理线程切换

### 2.5.5 异常与超时处理策略

#### 1. 网络错误处理

```cpp
void NetworkManager::onNetworkError(QNetworkReply::NetworkError error)
{
    QString errorString;
    switch (error) {
        case QNetworkReply::ConnectionRefusedError:
            errorString = "连接被拒绝，请检查服务器是否运行";
            break;
        case QNetworkReply::HostNotFoundError:
            errorString = "主机未找到，请检查URL配置";
            break;
        case QNetworkReply::TimeoutError:
            errorString = "请求超时，请检查网络连接";
            break;
        case QNetworkReply::NetworkAccessDeniedError:
            errorString = "网络访问被拒绝";
            break;
        default:
            errorString = QString("网络错误：%1").arg(error);
    }
    
    emit errorOccurred(errorString);
}
```

#### 2. JSON解析错误处理

```cpp
void NetworkManager::onCategoriesReplyFinished()
{
    QByteArray data = categoriesReply->readAll();
    QJsonParseError error;
    QJsonDocument doc = QJsonDocument::fromJson(data, &error);
    
    if (error.error != QJsonParseError::NoError) {
        emit errorOccurred("解析JSON失败：" + error.errorString());
        // 使用默认值
        QStringList defaultCategories = {"学术讲座", "文体活动", "社会实践", "志愿服务", "竞赛活动", "其他"};
        emit categoriesReceived(defaultCategories);
        return;
    }
    // ... 正常处理
}
```

#### 3. 超时处理

```cpp
// 设置请求超时（需要在创建请求时设置）
QNetworkRequest request(url);
request.setRawHeader("Connection", "close");

// 使用QTimer实现超时检测
QTimer *timeoutTimer = new QTimer(this);
timeoutTimer->setSingleShot(true);
timeoutTimer->setInterval(10000); // 10秒超时

connect(timeoutTimer, &QTimer::timeout, this, [this]() {
    if (categoriesReply && categoriesReply->isRunning()) {
        categoriesReply->abort();
        emit errorOccurred("请求超时");
    }
});

timeoutTimer->start();
categoriesReply = networkManager->get(request);
```

#### 4. 默认值处理策略

```cpp
// 获取活动类别失败时，返回默认类别列表
if (categoriesReply->error() != QNetworkReply::NoError) {
    QStringList defaultCategories;
    defaultCategories << "学术讲座" << "文体活动" << "社会实践" 
                      << "志愿服务" << "竞赛活动" << "其他";
    emit categoriesReceived(defaultCategories);
    return;
}
```

**处理策略总结**：
- **网络错误**：显示友好的错误提示，不中断用户操作
- **超时错误**：设置合理的超时时间，超时后使用默认值或提示用户
- **解析错误**：记录错误日志，使用默认值保证系统可用性
- **统一错误通知**：通过errorOccurred信号统一通知UI层

### 2.5.6 如何避免阻塞UI

#### 1. 异步请求机制

```cpp
// QNetworkAccessManager自动使用异步I/O
void NetworkManager::fetchActivityCategories()
{
    QUrl url(baseUrl + "/categories");
    QNetworkRequest request(url);
    
    // 异步执行，立即返回，不阻塞调用线程
    categoriesReply = networkManager->get(request);
    
    // 通过信号通知完成
    connect(networkManager, &QNetworkAccessManager::finished,
            this, &NetworkManager::onCategoriesReplyFinished);
}
```

#### 2. 事件循环机制

Qt的事件循环机制确保网络请求在后台执行：
- 网络I/O操作在Qt的事件循环中异步执行
- UI线程继续处理用户交互事件
- 请求完成后通过信号通知UI更新

#### 3. 进度提示

```cpp
// 显示加载状态
void MainWindow::onFetchCategories()
{
    statusLabel->setText("正在获取活动类别...");
    // 可以显示进度条或加载动画
    networkManager->fetchActivityCategories();
}

// 完成后更新状态
void MainWindow::onCategoriesReceived(const QStringList &categories)
{
    statusLabel->setText("活动类别获取成功");
    // 隐藏进度条
}
```

#### 4. 请求队列管理

```cpp
// 避免同时发起多个相同请求
void NetworkManager::fetchActivityCategories()
{
    if (categoriesReply && categoriesReply->isRunning()) {
        // 如果已有请求在进行，取消旧请求
        categoriesReply->abort();
        categoriesReply->deleteLater();
    }
    
    categoriesReply = networkManager->get(request);
}
```

**避免阻塞UI的关键点**：
- ✅ 使用QNetworkAccessManager的异步API
- ✅ 不在网络请求回调中执行耗时操作
- ✅ 通过信号槽机制更新UI，而不是直接调用
- ✅ 提供进度提示，让用户知道操作正在进行
- ✅ 设置合理的超时时间

---

## 2.6 多线程设计

### 2.6.1 为什么需要多线程？

#### 主要目的：避免UI阻塞

在多线程设计中，主要目的是将耗时操作从UI线程中分离出来，避免阻塞用户界面。

**需要多线程的场景**：

1. **数据导出操作**：
   - CSV文件导出涉及大量数据读写
   - 如果数据量大（如数千条报名记录），同步导出会导致UI冻结
   - 用户无法进行其他操作，体验极差

2. **网络请求**：
   - 虽然QNetworkAccessManager本身是异步的，但数据处理可能耗时
   - 大量数据的JSON解析和转换可能阻塞UI

3. **数据库查询**：
   - 复杂的统计查询可能耗时较长
   - 大数据量的查询操作应该放在后台线程

**当前系统的多线程应用**：
- **ExportThread**：用于CSV文件导出，避免导出大文件时UI冻结

### 2.6.2 使用QThread的理由

#### QThread vs QtConcurrent

**选择QThread的理由**：

1. **更细粒度的控制**：
   - 可以精确控制线程的生命周期
   - 可以自定义线程的run()方法
   - 可以发送进度信号

2. **信号槽通信**：
   - QThread继承自QObject，支持信号槽机制
   - 可以方便地与主线程通信
   - 线程安全的事件传递

3. **适合长时间运行的任务**：
   - 导出操作可能需要较长时间
   - 需要实时反馈进度
   - QThread更适合这种场景

**QtConcurrent的适用场景**：
- 简单的并行计算任务
- 不需要进度反馈的短时任务
- 函数式编程风格的任务

**代码对比**：

```cpp
// 使用QThread（当前实现）
class ExportThread : public QThread
{
    Q_OBJECT
signals:
    void exportProgress(int percentage);
    void exportFinished(bool success);
protected:
    void run() override {
        // 导出逻辑，可以发送进度信号
        emit exportProgress(50);
        // ...
    }
};

// 使用QtConcurrent（不适合当前场景）
QFuture<void> future = QtConcurrent::run([=]() {
    // 导出逻辑，但难以发送进度信号
    exporter->exportStatistics(filename, statistics);
});
```

### 2.6.3 Thread Worker类设计说明

#### ExportThread类设计

```cpp
class ExportThread : public QThread
{
    Q_OBJECT

public:
    explicit ExportThread(QObject *parent = nullptr);
    ~ExportThread();
    
    // 设置导出参数
    void setExportType(const QString &type);  // "registrations" or "statistics"
    void setFilename(const QString &filename);
    void setRegistrationsData(const QList<QHash<QString, QVariant>> &registrations,
                             const QHash<QString, QVariant> &activity);
    void setStatisticsData(const QList<QHash<QString, QVariant>> &statistics);

signals:
    void exportProgress(int percentage);      // 进度信号
    void exportFinished(bool success, const QString &message);  // 完成信号
    void exportError(const QString &error);  // 错误信号

protected:
    void run() override;  // 线程执行函数

private:
    QString exportType;
    QString filename;
    QList<QHash<QString, QVariant>> registrations;
    QHash<QString, QVariant> activity;
    QList<QHash<QString, QVariant>> statistics;
    CsvExporter *exporter;
};
```

#### 设计要点

1. **继承QThread**：
   - 继承自QThread，重写run()方法
   - 支持信号槽机制（Q_OBJECT宏）

2. **数据传递**：
   - 通过setter方法在主线程中设置数据
   - 数据在start()之前传递，避免线程安全问题

3. **进度反馈**：
   - 通过exportProgress信号发送进度百分比
   - UI可以显示进度条

4. **结果通知**：
   - 通过exportFinished信号通知完成状态
   - 通过exportError信号通知错误

5. **资源管理**：
   - 析构函数中调用wait()等待线程完成
   - 确保线程安全退出

#### 使用示例

```cpp
// 在主线程中创建和使用
ExportThread *exportThread = new ExportThread(this);
exportThread->setExportType("statistics");
exportThread->setFilename(filename);
exportThread->setStatisticsData(statistics);

// 连接信号
connect(exportThread, &ExportThread::exportProgress,
        this, [this](int percentage) {
    progressBar->setValue(percentage);
});

connect(exportThread, &ExportThread::exportFinished,
        this, [this](bool success, const QString &message) {
    if (success) {
        QMessageBox::information(this, "成功", message);
    } else {
        QMessageBox::warning(this, "失败", message);
    }
    exportThread->deleteLater();
});

// 启动线程
exportThread->start();
```

### 2.6.4 线程与UI通信流程图（信号槽）

```
┌─────────────────────────────────────────────────────────────────┐
│              线程与UI通信流程图（信号槽机制）                    │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                     主线程 (UI Thread)                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  ActivityManager / RegistrationManager                  │  │
│  │                                                          │  │
│  │  1. 用户点击"导出"按钮                                   │  │
│  │  2. 创建ExportThread对象                                 │  │
│  │  3. 设置导出参数（数据、文件名等）                       │  │
│  │  4. 连接信号槽                                           │  │
│  │  5. 调用start()启动线程                                  │  │
│  │                                                          │  │
│  │  connect(exportThread, &ExportThread::exportProgress,    │  │
│  │          this, [this](int p) {                          │  │
│  │      progressBar->setValue(p);  // 更新进度条           │  │
│  │  });                                                     │  │
│  │                                                          │  │
│  │  connect(exportThread, &ExportThread::exportFinished,   │  │
│  │          this, [this](bool s, QString m) {             │  │
│  │      showMessage(s, m);  // 显示结果                    │  │
│  │  });                                                     │  │
│  └──────────────────────────────────────────────────────────┘  │
│                            │                                    │
│                            │ start()                            │
│                            ▼                                    │
└────────────────────────────┼────────────────────────────────────┘
                             │
                             │ 创建新线程
                             │
┌────────────────────────────┼────────────────────────────────────┐
│                   工作线程 (Worker Thread)                       │
├────────────────────────────┼────────────────────────────────────┤
│                            │                                    │
│  ┌─────────────────────────▼──────────────────────────────────┐ │
│  │  ExportThread::run()                                     │ │
│  │                                                          │ │
│  │  1. 执行导出操作                                         │ │
│  │     - 打开文件                                           │ │
│  │     - 写入数据                                           │ │
│  │     - 处理大量数据                                       │ │
│  │                                                          │ │
│  │  2. 发送进度信号                                         │ │
│  │     emit exportProgress(10);                            │ │
│  │     emit exportProgress(50);                            │ │
│  │     emit exportProgress(100);                           │ │
│  │                                                          │ │
│  │  3. 发送完成信号                                         │ │
│  │     emit exportFinished(true, "导出成功");              │ │
│  │                                                          │ │
│  │  4. 线程结束                                             │ │
│  └──────────────────────────────────────────────────────────┘ │
│                            │                                    │
│                            │ emit信号（线程安全）                │
│                            ▼                                    │
└────────────────────────────┼────────────────────────────────────┘
                             │
                             │ Qt事件循环自动传递信号
                             │
┌────────────────────────────┼────────────────────────────────────┐
│                     主线程 (UI Thread)                          │
├────────────────────────────┼────────────────────────────────────┤
│                            │                                    │
│  ┌─────────────────────────▼──────────────────────────────────┐ │
│  │  信号槽机制自动调用                                        │ │
│  │                                                          │ │
│  │  • exportProgress信号 → 更新进度条                       │ │
│  │  • exportFinished信号 → 显示消息框                      │ │
│  │  • exportError信号 → 显示错误提示                        │ │
│  │                                                          │ │
│  │  所有UI更新都在主线程中执行，线程安全                     │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

关键点说明：
1. 数据传递：在主线程中通过setter方法设置数据，避免线程安全问题
2. 信号发送：在工作线程中emit信号，Qt自动传递到主线程
3. UI更新：所有UI操作都在主线程中执行，保证线程安全
4. 线程生命周期：线程完成后自动退出，通过deleteLater()清理资源
```

### 2.6.5 线程与主线程的关系

#### 1. 线程创建和启动

```cpp
// 在主线程中创建
ExportThread *exportThread = new ExportThread(this);

// 设置数据（在主线程中，start()之前）
exportThread->setExportType("statistics");
exportThread->setFilename(filename);
exportThread->setStatisticsData(statistics);

// 连接信号（在主线程中）
connect(exportThread, &ExportThread::exportProgress, ...);
connect(exportThread, &ExportThread::exportFinished, ...);

// 启动线程（创建新线程）
exportThread->start();  // 此时创建新线程，run()在新线程中执行
```

#### 2. 线程执行

```cpp
// run()方法在工作线程中执行
void ExportThread::run()
{
    // 这段代码在工作线程中执行
    // 可以执行耗时操作，不会阻塞UI
    
    emit exportProgress(10);  // 发送信号到主线程
    // ... 导出操作
    emit exportProgress(100);
    emit exportFinished(true, "导出成功");
}
```

#### 3. 信号槽通信

**线程安全的信号槽**：
- Qt的信号槽机制是线程安全的
- 在工作线程中emit信号，会自动排队传递到主线程
- 主线程的事件循环会处理这些信号，调用对应的槽函数

```cpp
// 工作线程中
emit exportProgress(50);  // 线程安全，自动传递到主线程

// 主线程中（通过信号槽连接）
connect(exportThread, &ExportThread::exportProgress,
        this, [this](int percentage) {
    // 这段代码在主线程中执行，可以安全地更新UI
    progressBar->setValue(percentage);
});
```

#### 4. 数据访问规则

**主线程 → 工作线程**：
- ✅ 通过setter方法传递数据（在start()之前）
- ✅ 传递基本类型和Qt类型（QString、QList等），Qt会自动处理

**工作线程 → 主线程**：
- ✅ 通过信号传递数据
- ✅ 不能直接访问UI对象
- ✅ 不能直接调用主线程的方法

**错误示例**：
```cpp
// ❌ 错误：在工作线程中直接访问UI
void ExportThread::run()
{
    // 错误！不能在工作线程中直接访问UI
    progressBar->setValue(50);  // 可能导致崩溃
}

// ✅ 正确：通过信号传递
void ExportThread::run()
{
    emit exportProgress(50);  // 正确，通过信号传递
}
```

#### 5. 线程生命周期

```cpp
// 创建线程
ExportThread *exportThread = new ExportThread(this);

// 启动线程
exportThread->start();  // 创建新线程，run()开始执行

// 等待线程完成（可选）
// exportThread->wait();  // 阻塞等待，一般不推荐

// 线程完成后清理
connect(exportThread, &ExportThread::exportFinished,
        this, [exportThread](bool success, const QString &message) {
    // 处理结果
    exportThread->deleteLater();  // 延迟删除，线程安全
});
```

#### 6. 线程关系总结

```
主线程 (UI Thread)
├── 创建ExportThread对象
├── 设置数据（setter方法）
├── 连接信号槽
├── 启动线程（start()）
│
├── 接收信号（信号槽自动调用）
│   ├── exportProgress → 更新进度条
│   ├── exportFinished → 显示结果
│   └── exportError → 显示错误
│
└── 清理资源（deleteLater()）

工作线程 (Worker Thread)
├── run()方法执行
│   ├── 执行耗时操作（文件I/O、数据处理）
│   ├── 发送进度信号（emit exportProgress）
│   └── 发送完成信号（emit exportFinished）
│
└── 线程结束

关键点：
1. 主线程负责UI更新和用户交互
2. 工作线程负责耗时操作
3. 通过信号槽机制进行线程间通信
4. 数据传递在start()之前完成
5. UI更新必须在主线程中执行
```

---

## 2.7 UI 布局设计

### 2.7.1 主界面布局结构

#### 整体布局层次

```
┌─────────────────────────────────────────────────────────────────┐
│                    MainWindow (QMainWindow)                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  MenuBar (QMenuBar)                                      │  │
│  │  文件(F)  网络(N)  帮助(H)                               │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  CentralWidget (QWidget)                                 │  │
│  │  ┌────────────────────────────────────────────────────┐  │  │
│  │  │  MainLayout (QVBoxLayout)                         │  │  │
│  │  │                                                    │  │  │
│  │  │  ┌──────────────────────────────────────────────┐ │  │  │
│  │  │  │  UserLayout (QHBoxLayout)                    │ │  │  │
│  │  │  │  [用户信息标签]  [退出登录按钮]              │ │  │  │
│  │  │  └──────────────────────────────────────────────┘ │  │  │
│  │  │                                                    │  │  │
│  │  │  ┌──────────────────────────────────────────────┐ │  │  │
│  │  │  │  TabWidget (QTabWidget)                     │ │  │  │
│  │  │  │  ┌──────────────┐  ┌──────────────┐        │ │  │  │
│  │  │  │  │ 活动管理     │  │ 报名管理      │        │ │  │  │
│  │  │  │  └──────────────┘  └──────────────┘        │ │  │  │
│  │  │  │                                              │ │  │  │
│  │  │  │  ┌──────────────────────────────────────┐  │ │  │  │
│  │  │  │  │  ActivityManager /                    │  │ │  │  │
│  │  │  │  │  RegistrationManager                  │  │ │  │  │
│  │  │  │  │  (根据用户角色显示不同内容)            │  │ │  │  │
│  │  │  │  └──────────────────────────────────────┘  │ │  │  │
│  │  │  └──────────────────────────────────────────────┘ │  │  │
│  │  └────────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  StatusBar (QStatusBar)                                  │  │
│  │  [状态标签：就绪/欢迎信息]                                │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

#### 代码实现

```cpp
void MainWindow::setupUI()
{
    setWindowTitle("校园活动报名与签到管理系统");
    setMinimumSize(1000, 700);
    
    // 创建中央部件
    QWidget *centralWidget = new QWidget(this);
    setCentralWidget(centralWidget);
    
    // 主布局（垂直布局）
    QVBoxLayout *mainLayout = new QVBoxLayout(centralWidget);
    
    // 用户信息布局（水平布局）
    QHBoxLayout *userLayout = new QHBoxLayout();
    userLabel = new QLabel("未登录");
    QPushButton *logoutButton = new QPushButton("退出登录");
    userLayout->addWidget(userLabel);
    userLayout->addStretch();  // 添加弹性空间
    userLayout->addWidget(logoutButton);
    mainLayout->addLayout(userLayout);
    
    // 创建标签页
    tabWidget = new QTabWidget();
    mainLayout->addWidget(tabWidget);
    
    // 状态栏
    statusLabel = new QLabel("就绪");
    statusBar()->addWidget(statusLabel);
}
```

### 2.7.2 使用的布局管理器

#### 1. QVBoxLayout（垂直布局）

**使用位置**：
- MainWindow的主布局
- ActivityManager和RegistrationManager的主布局
- 对话框的布局

**特点**：
- 子控件垂直排列
- 自动调整高度
- 支持stretch因子控制空间分配

**示例**：
```cpp
QVBoxLayout *mainLayout = new QVBoxLayout(centralWidget);
mainLayout->addWidget(userLabel);
mainLayout->addWidget(tabWidget);
mainLayout->addStretch();  // 添加弹性空间
```

#### 2. QHBoxLayout（水平布局）

**使用位置**：
- 用户信息栏（用户标签 + 退出按钮）
- 按钮组（创建、审批、拒绝等按钮）
- 搜索栏（搜索框 + 搜索按钮）

**特点**：
- 子控件水平排列
- 自动调整宽度
- 支持stretch因子

**示例**：
```cpp
QHBoxLayout *buttonLayout = new QHBoxLayout();
buttonLayout->addWidget(createButton);
buttonLayout->addWidget(approveButton);
buttonLayout->addStretch();  // 按钮靠左，右侧留空
buttonLayout->addWidget(refreshButton);
```

#### 3. QGridLayout（网格布局）

**使用位置**：
- 活动创建/编辑对话框
- 表单输入界面

**特点**：
- 按行列组织控件
- 适合表单布局
- 可以跨行跨列

**示例**：
```cpp
QGridLayout *formLayout = new QGridLayout();
formLayout->addWidget(new QLabel("标题："), 0, 0);
formLayout->addWidget(titleEdit, 0, 1);
formLayout->addWidget(new QLabel("描述："), 1, 0);
formLayout->addWidget(descriptionEdit, 1, 1);
```

#### 4. QTabWidget（标签页）

**使用位置**：
- MainWindow中的活动管理和报名管理标签页
- RegistrationManager中的学生端标签页（我的报名、可报名活动）

**特点**：
- 多个页面切换
- 节省界面空间
- 按功能分组

**示例**：
```cpp
QTabWidget *tabWidget = new QTabWidget();
tabWidget->addTab(activityManager, "活动管理");
tabWidget->addTab(registrationManager, "报名管理");
```

### 2.7.3 UI样式与功能对应关系

#### 1. 按钮功能映射

| 按钮 | 功能 | 触发操作 | 权限要求 |
|------|------|---------|---------|
| 创建活动 | 打开活动创建对话框 | onCreateActivity() | 发起人、管理员 |
| 审批活动 | 批准选中的活动 | onApproveActivity() | 管理员 |
| 拒绝活动 | 拒绝选中的活动 | onRejectActivity() | 管理员 |
| 查看详情 | 显示活动详细信息 | onViewDetails() | 所有角色 |
| 搜索 | 按关键词搜索活动 | onSearchActivities() | 所有角色 |
| 刷新 | 刷新活动列表 | onRefreshActivities() | 所有角色 |
| 同步 | 同步活动到校园平台 | onManualSync() | 发起人、管理员 |
| 报名 | 报名选中的活动 | onRegisterActivity() | 学生 |
| 取消报名 | 取消已报名的活动 | onCancelRegistration() | 学生 |
| 签到 | 学生签到 | onCheckIn() | 学生 |
| 导出CSV | 导出报名名单 | onExportCSV() | 发起人、管理员 |

#### 2. 表格显示内容

**活动管理表格**（ActivityManager）：
- 列：ID、标题、类别、发起人、开始时间、结束时间、地点、状态、参与人数
- 根据用户角色过滤：
  - 管理员：显示所有活动
  - 发起人：只显示自己创建的活动
  - 学生：只显示已批准的活动

**报名管理表格**（RegistrationManager）：
- 学生角色：
  - "我的报名"标签页：显示已报名的活动列表
  - "可报名活动"标签页：显示可以报名的活动列表
- 发起人/管理员角色：
  - 显示选中活动的报名学生列表

#### 3. 对话框功能

**活动创建/编辑对话框**：
- 输入字段：标题、描述、类别、开始时间、结束时间、最大人数、地点
- 按钮：确定、取消
- 功能：创建新活动或编辑现有活动

**活动详情对话框**：
- 显示：活动所有信息（只读）
- 学生角色：显示"报名"按钮
- 发起人/管理员角色：显示"编辑"按钮

**签到对话框**：
- 输入：签到码（学生端）
- 功能：验证签到码并完成签到

#### 4. 菜单功能

**文件菜单**：
- 新建窗口：创建新的主窗口实例
- 导出统计报表：导出CSV格式的统计报表（仅管理员）
- 退出：关闭应用程序

**网络菜单**：
- 获取活动类别：从服务器获取活动类别列表
- 获取公告：从服务器获取公告列表

**帮助菜单**：
- 关于：显示应用程序信息

### 2.7.4 UI设计逻辑说明

#### 1. 角色驱动的UI设计

**设计原则**：
- 根据用户角色动态显示不同的UI元素
- 隐藏用户无权访问的功能
- 提供清晰的权限提示

**实现方式**：
```cpp
void MainWindow::updateUIForRole()
{
    // 根据角色显示不同的标签页
    switch (currentRole) {
        case UserRole::Admin:
            // 显示所有功能
            break;
        case UserRole::Organizer:
            // 隐藏审批功能
            break;
        case UserRole::Student:
            // 只显示报名相关功能
            break;
    }
}
```

#### 2. 响应式布局设计

**设计原则**：
- 使用stretch因子控制空间分配
- 表格自动调整列宽
- 窗口大小变化时自动调整布局

**实现方式**：
```cpp
// 按钮靠左，右侧留空
buttonLayout->addWidget(createButton);
buttonLayout->addStretch();  // 弹性空间
buttonLayout->addWidget(refreshButton);

// 表格列自动拉伸
tableView->horizontalHeader()->setStretchLastSection(true);
```

#### 3. 用户反馈设计

**设计原则**：
- 操作后立即反馈结果
- 显示操作进度（如导出进度条）
- 错误时显示友好提示

**实现方式**：
```cpp
// 状态栏提示
statusLabel->setText("正在导出...");

// 进度条
connect(exportThread, &ExportThread::exportProgress,
        this, [this](int percentage) {
    progressBar->setValue(percentage);
});

// 消息框
QMessageBox::information(this, "成功", "操作完成！");
```

#### 4. 数据驱动的UI更新

**设计原则**：
- UI自动响应数据变化
- 选择变化时更新相关按钮状态
- 数据刷新时自动更新显示

**实现方式**：
```cpp
// 选择变化时更新按钮状态
connect(activitiesTable, &QTableWidget::itemSelectionChanged,
        this, &ActivityManager::onActivitySelectionChanged);

void ActivityManager::onActivitySelectionChanged()
{
    bool hasSelection = getSelectedActivityId() > 0;
    approveButton->setEnabled(hasSelection);
    rejectButton->setEnabled(hasSelection);
    viewButton->setEnabled(hasSelection);
}
```

### 2.7.5 UI布局示意图

```
┌─────────────────────────────────────────────────────────────────┐
│                    主界面布局示意图                               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  菜单栏: 文件(F)  网络(N)  帮助(H)                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  用户信息栏 (QHBoxLayout)                                 │  │
│  │  [用户：张三 (2021001) - 学生]        [退出登录]          │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  标签页 (QTabWidget)                                     │  │
│  │  ┌──────────────┐  ┌──────────────┐                      │  │
│  │  │ [活动管理]   │  │ [报名管理]   │                      │  │
│  │  └──────────────┘  └──────────────┘                      │  │
│  │                                                           │  │
│  │  ┌─────────────────────────────────────────────────────┐ │  │
│  │  │  活动管理页面 (ActivityManager)                     │ │  │
│  │  │                                                     │ │  │
│  │  │  ┌───────────────────────────────────────────────┐ │ │  │
│  │  │  │  操作栏 (QHBoxLayout)                        │ │ │  │
│  │  │  │  [创建活动] [审批] [拒绝] [查看] [搜索框] [搜索] [刷新] [同步] │ │  │
│  │  │  └───────────────────────────────────────────────┘ │ │  │
│  │  │                                                     │ │  │
│  │  │  ┌───────────────────────────────────────────────┐ │ │  │
│  │  │  │  活动列表表格 (QTableWidget)                 │ │ │  │
│  │  │  │  ID │ 标题 │ 类别 │ 发起人 │ 时间 │ 状态 │ ... │ │  │
│  │  │  │  ──┼─────┼─────┼───────┼─────┼─────┼─────│ │  │
│  │  │  │  1 │ 讲座 │ 学术 │ 张三  │ ... │ 已批准│ ... │ │  │
│  │  │  │  2 │ 比赛 │ 竞赛 │ 李四  │ ... │ 待审批│ ... │ │  │
│  │  │  └───────────────────────────────────────────────┘ │ │  │
│  │  └─────────────────────────────────────────────────────┘ │  │
│  │                                                           │  │
│  │  或                                                       │  │
│  │                                                           │  │
│  │  ┌─────────────────────────────────────────────────────┐ │  │
│  │  │  报名管理页面 (RegistrationManager)                 │ │  │
│  │  │                                                     │ │  │
│  │  │  ┌──────────────┐  ┌──────────────┐                │ │  │
│  │  │  │ [我的报名]   │  │ [可报名活动] │                │ │  │
│  │  │  └──────────────┘  └──────────────┘                │ │  │
│  │  │                                                     │ │  │
│  │  │  ┌───────────────────────────────────────────────┐ │ │  │
│  │  │  │  表格 + 操作按钮                              │ │ │  │
│  │  │  └───────────────────────────────────────────────┘ │ │  │
│  │  └─────────────────────────────────────────────────────┘ │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│  状态栏: [就绪] 或 [欢迎，张三 (2021001)]                        │
└─────────────────────────────────────────────────────────────────┘
```

**布局特点总结**：
1. **层次清晰**：菜单栏 → 用户信息栏 → 内容区 → 状态栏
2. **功能分组**：使用标签页将不同功能分组
3. **操作便捷**：常用操作按钮放在显眼位置
4. **信息丰富**：表格显示详细信息，状态栏提供实时反馈
5. **响应式**：布局自动适应窗口大小变化

---

## 总结

本文档详细说明了校园活动管理系统的以下设计方面：

1. **Model/View设计**：说明了数据库结构（E-R图、表结构）、当前使用的QTableWidget方式，以及如何改用Model/View架构
2. **网络模块设计**：说明了HTTP协议的使用、异步请求流程、UI更新机制、异常处理和避免UI阻塞的方法
3. **多线程设计**：说明了为什么需要多线程、QThread的使用理由、Worker类设计、线程通信机制和线程关系
4. **UI布局设计**：说明了主界面布局结构、使用的布局管理器、UI样式与功能的对应关系，以及UI设计逻辑

所有设计都基于实际代码实现，确保了文档的准确性和可操作性。
