# 3.4 AI 工具使用记录

## 3.4.1 使用的 AI 工具清单

| AI 工具名称 | 版本/平台 | 使用目的（例如：查错、设计建议、代码片段等） |
|------------|----------|--------------------------------------------|
| DeepSeek | Web版 | 代码实现、错误修复、Qt框架使用指导、多线程实现建议 |
| 其他： | | |

---

## 3.4.2 核心提示词（Prompt）记录（至少 3 条）

每条包括：
- Prompt 内容
- AI 输出的摘要
- 自己如何修改、如何理解

| 序号 | Prompt（输入的提示词） | AI 输出摘要（学生整理） | 修改内容与理解（必须自行描述） |
|------|----------------------|----------------------|---------------------------|
| 1 | 如何在Qt中使用QThread实现后台线程，避免阻塞UI？需要实现一个导出CSV文件的后台线程，并显示进度。 | AI提供了QThread的基本用法，建议继承QThread类并重写run()方法。提供了信号槽机制用于线程间通信的示例代码，包括emit信号发送进度和完成状态。建议使用QTextCodec处理UTF-8编码。 | **问题**：AI提供的代码示例中，直接在run()方法中访问UI组件，这会导致线程安全问题。<br><br>**修改**：1) 将数据通过setter方法传入线程类，而不是直接访问UI；2) 使用信号emit exportProgress()和exportFinished()来通知主线程更新UI；3) 在主线程中连接这些信号到UI更新槽函数；4) 添加了异常处理机制，使用try-catch捕获导出过程中的错误。<br><br>**理解**：Qt的线程安全原则是：只有主线程可以访问UI，工作线程只能通过信号槽机制与主线程通信。这确保了UI操作的线程安全性。 |
| 2 | Qt 5.12和Qt 5.15中QNetworkReply的错误信号连接方式不同，如何兼容两个版本？ | AI指出Qt 5.15引入了errorOccurred信号替代了error信号，并提供了使用QOverload和static_cast的两种连接方式。建议使用QT_VERSION_CHECK宏进行版本判断。 | **问题**：AI提供的QOverload语法在Qt 5.12中可能编译不通过，static_cast方式虽然兼容但语法复杂。<br><br>**修改**：1) 使用条件编译#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)区分版本；2) Qt 5.15+使用QOverload方式连接errorOccurred信号；3) Qt 5.12使用static_cast方式连接error信号；4) 两种方式都使用相同的槽函数onNetworkError处理错误。<br><br>**理解**：Qt在不同版本间API会有变化，使用条件编译可以保证代码在不同Qt版本下都能正常编译和运行。这是Qt跨版本兼容的标准做法。 |
| 3 | 如何实现CSV文件导出，确保Excel能正确显示中文？需要支持UTF-8编码和特殊字符转义。 | AI提供了使用QFile和QTextStream写入CSV的基本方法，建议使用UTF-8编码。提到了CSV字段转义规则：包含逗号、引号或换行符的字段需要用引号括起来，引号需要转义为两个引号。 | **问题**：AI的示例代码没有写入UTF-8 BOM，导致Excel打开CSV文件时中文显示为乱码。另外，转义逻辑不够完善。<br><br>**修改**：1) 在文件开头写入UTF-8 BOM（0xEF 0xBB 0xBF），这样Excel才能正确识别UTF-8编码；2) 实现了escapeCsvField()方法，正确处理包含逗号、引号、换行符的字段；3) 使用QTextCodec::codecForName("UTF-8")确保编码正确；4) 使用QIODevice::WriteOnly以二进制模式打开文件，避免文本模式下的换行符转换问题。<br><br>**理解**：Windows下的Excel默认使用系统编码（GBK）打开CSV文件，只有添加UTF-8 BOM才能让Excel识别为UTF-8编码。这是Windows平台CSV文件中文显示的关键。 |
| 4 | 如何在Qt中实现异步时间冲突检测？学生报名活动时需要检查是否与其他已报名活动时间冲突，但不能阻塞UI。 | AI建议使用QThread在后台执行数据库查询，通过信号槽返回结果。提供了基本的线程类框架和信号定义。 | **问题**：AI的示例代码中，数据库对象在多个线程间共享，可能导致线程安全问题。另外，没有考虑如何传递查询参数和返回结果。<br><br>**修改**：1) 在ConflictChecker线程类中添加setStudentId()和setActivityTime()方法，在主线程中设置参数；2) 在run()方法中调用database->checkTimeConflict()执行查询；3) 使用QList<QHash<QString, QVariant>>作为冲突结果的返回类型，通过信号conflictDetected()发送；4) 确保Database对象是线程安全的，或者只在主线程中创建数据库连接，工作线程通过信号请求主线程执行查询。<br><br>**理解**：SQLite支持多线程访问，但需要正确配置连接。Qt的QSqlDatabase默认不是线程安全的，每个线程需要有自己的数据库连接。但在本项目中，由于使用QThread的run()方法，实际上仍在主线程的数据库连接上下文中执行，所以是安全的。 |
| 5 | Qt中如何实现活动批准后自动同步到服务器？需要发送POST请求，包含JSON数据，并处理响应和错误。 | AI提供了使用QNetworkAccessManager发送POST请求的示例，包括设置请求头Content-Type为application/json，使用QJsonDocument构建JSON数据，通过QNetworkReply读取响应。 | **问题**：AI的代码示例中，网络请求是异步的，但没有正确处理请求的生命周期管理，可能导致内存泄漏。另外，错误处理不够完善。<br><br>**修改**：1) 在NetworkManager类中维护QNetworkReply指针，在析构函数中调用deleteLater()确保正确释放；2) 使用finished信号统一处理所有网络请求的完成，通过比较reply指针判断是哪个请求完成；3) 添加了网络错误处理，包括超时、连接失败等情况；4) 在活动批准时自动调用syncActivity()方法，不阻塞UI；5) 同步失败时显示错误提示，但不影响活动的正常使用。<br><br>**理解**：Qt的网络请求是异步的，需要正确管理QNetworkReply对象的生命周期。使用finished信号比使用readyRead更可靠，因为它会在请求完全结束后触发，无论成功还是失败。 |

---

## 3.4.3 AI 代码问题分析（至少 2 例）

要回答：
- 出现什么问题？
- 为什么不正确？
- 如何修复？

### 问题1：Qt版本兼容性问题 - QNetworkReply错误信号连接

**出现什么问题？**

在实现NetworkManager类时，AI提供的代码示例使用了Qt 5.15的新API `errorOccurred`信号：

```cpp
connect(reply, &QNetworkReply::errorOccurred, this, &NetworkManager::onNetworkError);
```

但在Qt 5.12环境下编译时，编译器报错：`error: 'errorOccurred' is not a member of 'QNetworkReply'`。

**为什么不正确？**

Qt 5.12版本中，QNetworkReply只有`error(QNetworkReply::NetworkError)`信号，没有`errorOccurred`信号。`errorOccurred`信号是在Qt 5.15版本中引入的，用于替代已废弃的`error`信号。AI提供的代码没有考虑Qt版本差异，直接使用了新版本的API，导致在旧版本Qt中无法编译。

**如何修复？**

使用条件编译根据Qt版本选择不同的连接方式：

```cpp
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    // Qt 5.15+使用新的errorOccurred信号
    connect(categoriesReply, QOverload<QNetworkReply::NetworkError>::of(&QNetworkReply::errorOccurred),
            this, &NetworkManager::onNetworkError);
#else
    // Qt 5.12使用旧的error信号
    connect(categoriesReply, static_cast<void(QNetworkReply::*)(QNetworkReply::NetworkError)>(&QNetworkReply::error),
            this, &NetworkManager::onNetworkError);
#endif
```

这样可以在不同Qt版本下都能正常编译和运行。同时，由于Qt 5.12的`error`信号需要函数指针转换（因为存在重载），使用`static_cast`来明确指定信号类型。

---

### 问题2：CSV文件中文乱码问题

**出现什么问题？**

使用AI提供的CSV导出代码后，导出的CSV文件在Excel中打开时，中文字符显示为乱码（如"活动标题"显示为"æ´»å¨æ å¢"），但在文本编辑器中打开显示正常。

**为什么不正确？**

AI提供的代码虽然使用了UTF-8编码写入文件：

```cpp
QTextStream out(&file);
out.setCodec("UTF-8");
out << content;
```

但Excel在Windows系统下打开CSV文件时，默认使用系统编码（通常是GBK/GB2312）来解析文件，而不是UTF-8。即使文件是UTF-8编码，Excel也无法正确识别，导致中文显示乱码。

**如何修复？**

需要在CSV文件开头添加UTF-8 BOM（Byte Order Mark），这样Excel才能识别文件为UTF-8编码：

```cpp
// 写入UTF-8 BOM
QByteArray bom;
bom.append(static_cast<char>(0xEF));
bom.append(static_cast<char>(0xBB));
bom.append(static_cast<char>(0xBF));
file.write(bom);

// 然后写入UTF-8编码的内容
QTextCodec *utf8Codec = QTextCodec::codecForName("UTF-8");
QByteArray utf8Data = utf8Codec->fromUnicode(content);
file.write(utf8Data);
```

另外，文件需要以二进制模式打开（`QIODevice::WriteOnly`），避免文本模式下的换行符转换影响BOM的正确写入。

修复后，Excel可以正确识别UTF-8编码，中文显示正常。

---

### 问题3：线程中直接访问UI组件导致程序崩溃

**出现什么问题？**

在实现ExportThread时，AI提供的示例代码中，在run()方法里直接调用UI相关的方法来更新进度条：

```cpp
void ExportThread::run() {
    // AI提供的错误示例
    mainWindow->progressBar->setValue(50);  // 直接访问UI组件
    // ...
}
```

程序运行时偶尔会出现崩溃，错误信息提示"QObject::setParent: Cannot set parent, new parent is in a different thread"。

**为什么不正确？**

Qt的UI组件只能在主线程（GUI线程）中访问和修改。工作线程（QThread的run()方法）运行在不同的线程中，直接访问UI组件违反了Qt的线程安全规则，会导致未定义行为，包括程序崩溃、UI冻结等问题。

**如何修复？**

使用信号槽机制进行线程间通信，让工作线程通过信号通知主线程更新UI：

```cpp
// ExportThread类中定义信号
signals:
    void exportProgress(int percentage);
    void exportFinished(bool success, const QString &message);

// run()方法中发送信号
void ExportThread::run() {
    emit exportProgress(50);  // 发送进度信号
    // ... 执行导出操作
    emit exportFinished(true, "导出成功");
}

// 主线程中连接信号到UI更新
connect(exportThread, &ExportThread::exportProgress, 
        this, [this](int value) {
    progressBar->setValue(value);  // 在主线程中更新UI
});
```

这样确保了UI操作始终在主线程中执行，符合Qt的线程安全要求。信号槽机制是Qt推荐的跨线程通信方式，会自动处理线程间的消息传递。
